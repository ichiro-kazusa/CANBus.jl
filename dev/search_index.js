var documenterSearchIndex = {"docs":
[{"location":"frames/#Frames","page":"Frames","title":"Frames","text":"","category":"section"},{"location":"frames/","page":"Frames","title":"Frames","text":"In CANBus.jl, send/receive messages are represented in CANBus.Frames module. For CAN frame, Frame is used, or for CAN FD frame, FDFrame is used.","category":"page"},{"location":"frames/#Base-type","page":"Frames","title":"Base type","text":"","category":"section"},{"location":"frames/#CANBus.Frames.AbstractFrame","page":"Frames","title":"CANBus.Frames.AbstractFrame","text":"Abstract type for Frames.\n\n\n\n\n\n","category":"type"},{"location":"frames/#Frame","page":"Frames","title":"Frame","text":"","category":"section"},{"location":"frames/#CANBus.Frames.Frame","page":"Frames","title":"CANBus.Frames.Frame","text":"CANBus.Frame(id::Integer, data::AbstractVector, is_extended:Bool)\n\nFrame struct represents classic (8bytes) CAN frame.\n\nid: arbitration id\ndata: Vector of Integer with length <= 8. If input has element > 255, throws error.\nis_extended: Flag which arbitration id is extended.\n\nframe = CANBus.Frame(0x5, [1, 2, 3, 4, 5, 6, 7, 8], true)\n\n\n\n\n\n","category":"type"},{"location":"frames/#FDFrame","page":"Frames","title":"FDFrame","text":"","category":"section"},{"location":"frames/#CANBus.Frames.FDFrame","page":"Frames","title":"CANBus.Frames.FDFrame","text":"CANBus.FDFrame(id::Integer, data::AbstractVector, is_extended::Bool,\n    bitrate_switch::Bool, error_state::Bool)\n\nFDFrame struct represents CAN FD (64bytes) frame.\n\nid: arbitration id\ndata: Vector of Integer. Length must be in CAN FD DLC standard. Elements must not be > 255.\nis_extended: Flag which arbitration id is extended.\nbitrate_switch: Flag to use bitrate_switch.\nerror_state: Flag corresponds to error_state_indicator.   This is used in receiving, so that it is ignore in transmitting (always treat as =false).\n\n\n\n\n\n","category":"type"},{"location":"frames/#Compatibility-with-CANalyze-package","page":"Frames","title":"Compatibility with CANalyze package","text":"","category":"section"},{"location":"frames/","page":"Frames","title":"Frames","text":"Frame and FDFrame has intercompatibility with CANalyze.CANFrame and CANAlyze.CANFdFrame respectively.","category":"page"},{"location":"frames/","page":"Frames","title":"Frames","text":"For instance, Frame constructor has a converter from CANalyze.CANFrame struct, you can use it like below:","category":"page"},{"location":"frames/","page":"Frames","title":"Frames","text":"using CANBus\nusing CANalyze\n\nvector1 = VectorInterface(0, 500000, \"NewApp\")\n\nfrm = CANalyze.CANFrame(1, [1, 2, 3, 4, 5, 6, 7, 8])\nmsg = Frame(frm)\nsend(vector1, msg)","category":"page"},{"location":"frames/","page":"Frames","title":"Frames","text":"In the opposite direction, CANalyze.CANFrame and CANalyze.CANFdFrame constructors are overridden,  so that you can feed Frame and FDFrame structs to CANalyze.Decode.decode function with conversion.","category":"page"},{"location":"frames/","page":"Frames","title":"Frames","text":"frm = CANBus.Frame(0x0e, [1, 2, 3, 4], false)\n\nsignal = CANalyze.Signals.NamedSignal(\"myfloat\", nothing, nothing,\n    CANalyze.Signals.Float32Signal(start=0; byte_order=:little_endian))\nmsg = CANalyze.Messages.Message(0x0e, 4, \"msg1\", signal)\n\nd = CANalyze.Decode.decode(msg, CANalyze.Frames.CANFrame(frm))","category":"page"},{"location":"interfaces/#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"interfaces/#Base-type","page":"Interfaces","title":"Base type","text":"","category":"section"},{"location":"interfaces/#CANBus.Interfaces.AbstractCANInterface","page":"Interfaces","title":"CANBus.Interfaces.AbstractCANInterface","text":"Abstract type for Interfaces.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#CANBus.Interfaces.send","page":"Interfaces","title":"CANBus.Interfaces.send","text":"send(interface::T<:AbstractCANInterface, frame::AbstractFrame)\n\nAbstract function for send message.\n\nCommon behavior of concrete implements:\n\nWhen send successed, return nothing.\nWhen send failed, throws error.\n\n\n\n\n\n","category":"function"},{"location":"interfaces/#CANBus.Interfaces.recv","page":"Interfaces","title":"CANBus.Interfaces.recv","text":"recv(interface::T<:AbstractCANInterface)\n\nAbstract function for receive message.\n\nCommon behavior of concrete implements:\n\nnon-blocking\nWhen receive successed, returns Frame or FDFrame.\nWhen receive queue is empty, returns nothing.\nWhen fails to receive in other reasons, throws error.\n\n\n\n\n\n","category":"function"},{"location":"interfaces/#CANBus.Interfaces.shutdown","page":"Interfaces","title":"CANBus.Interfaces.shutdown","text":"shutdown(interface::T<:AbstractCANInterface)\n\nAbstract function for shutdown interface. Always returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"interfaces/#Fiilter-struct","page":"Interfaces","title":"Fiilter struct","text":"","category":"section"},{"location":"interfaces/#CANBus.Interfaces.AcceptanceFilter","page":"Interfaces","title":"CANBus.Interfaces.AcceptanceFilter","text":"AcceptanceFilter(code_id, mask)\n\nStruct for accept filter. \n\nIf this struct is set to Interface, the id is accepted when  <received_id> & mask == code_id & mask or (<received_id> xor code_id) & mask == 0. Those are equivalent.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#Kvaser","page":"Interfaces","title":"Kvaser","text":"","category":"section"},{"location":"interfaces/#CANBus.Interfaces.KvaserInterfaces.KvaserInterface","page":"Interfaces","title":"CANBus.Interfaces.KvaserInterfaces.KvaserInterface","text":"KvaserInterface(channel::Int, bitrate::Int;\n    silent::Bool, stdfilter::AcceptanceFilter, extfilter::AcceptanceFilter)\n\nSetup Kvaser interface\n\nchannel: channel number in integer.\nbitrate: bitrate as bit/s in integer.\nsilent(optional): listen only flag in bool.\nstdfilter(optional): standard ID filter in AcceptanceFilter struct.\nextfilter(optional): extended ID filter in AcceptanceFilter struct.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#CANBus.Interfaces.KvaserInterfaces.KvaserFDInterface","page":"Interfaces","title":"CANBus.Interfaces.KvaserInterfaces.KvaserFDInterface","text":"KvaserFDInterface(channel::Int, bitrate::Int, datarate::Int;\n    non_iso::Bool, silent::Bool, stdfilter::AcceptanceFilter, extfilter::AcceptanceFilter)\n\nSetup Kvaser interface for CAN FD.\n\nchannel: channel number in integer.\nbitrate: bitrate as bit/s in integer.\ndatarate: datarate as bit/s in integer.\nnon_iso(optional): use non-iso version of CAN FD\nsilent(optional): listen only flag in bool.\nstdfilter(optional): standard ID filter in AcceptanceFilter struct.\nextfilter(optional): extended ID filter in AcceptanceFilter struct.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#SocketCAN","page":"Interfaces","title":"SocketCAN","text":"","category":"section"},{"location":"interfaces/#CANBus.Interfaces.SocketCANInterfaces.SocketCANInterface","page":"Interfaces","title":"CANBus.Interfaces.SocketCANInterfaces.SocketCANInterface","text":"SocketCANInterface(channel::String; filters::Vector{AcceptanceFilter})\n\nSetup SocketCAN interface.\n\nchannel: channel name string, e.g. \"can0\"\nfilters(optional): list of filters. experimental.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#CANBus.Interfaces.SocketCANInterfaces.SocketCANFDInterface","page":"Interfaces","title":"CANBus.Interfaces.SocketCANInterfaces.SocketCANFDInterface","text":"SocketCANFDInterface(channel::String; filters::Vector{AcceptanceFilter})\n\nSetup SocketCAN for CAN FD.\n\nchannel: channel name string, e.g. \"can0\"\nfilters(optional): list of filters. experimental.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#Vector","page":"Interfaces","title":"Vector","text":"","category":"section"},{"location":"interfaces/#CANBus.Interfaces.VectorInterfaces.VectorInterface","page":"Interfaces","title":"CANBus.Interfaces.VectorInterfaces.VectorInterface","text":"VectorInterface(channel::Int, bitrate::Int, appname::String)\n\nSetup Vector interface.\n\nchannel: channel number in integer.\nbitrate: bitrate as bit/s in integer.\napppname: Application Name string in Vector Hardware Manager.\nsilent(optional): listen only flag in bool.\nstdfilter(optional): standard ID filter in AcceptanceFilter struct.\nextfilter(optional): extended ID filter in AcceptanceFilter struct.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#CANBus.Interfaces.VectorInterfaces.VectorFDInterface","page":"Interfaces","title":"CANBus.Interfaces.VectorInterfaces.VectorFDInterface","text":"VectorFDInterface(channel::Int, bitrate::Int, datarate::Int, appname::String)\n\nSetup Vector interface for CAN FD.\n\nchannel: channel number in integer.\nbitrate: bitrate as bit/s in integer.\ndatarate: datarate as bit/s in integer.\napppname: Application Name string in Vector Hardware Manager.\nnon_iso(optional): use non-iso version of CAN FD\nsilent(optional): listen only flag in bool.\nstdfilter(optional): standard ID filter in AcceptanceFilter struct.\nextfilter(optional): extended ID filter in AcceptanceFilter struct.\n\n\n\n\n\n","category":"type"},{"location":"examples/#Example-Usage","page":"Example Usage","title":"Example Usage","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Let us assume that we have 2-channel Vector interface, the simplest example is below:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"using CANBus\nusing CANalyze\n\nfunction main()\n    vector1 = VectorInterface(0, 500000, \"NewApp\")\n    vector2 = VectorInterface(1, 500000, \"NewApp\")\n\n    frame = CANalyze.CANFrame(15, [1, 1, 2, 2, 3, 3, 4]; is_extended=true)\n\n    send(vector1, frame)\n\n    frame = recv(vector2) # non-blocking receive\n    println(frame)\n\n    frame = recv(vector2) # returns nothing\n    println(frame)\n\n    shutdown(vector1)\n    shutdown(vector2)\nend\n\nmain()","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Arguments of interface setup are different depends on kind of interface, see References.","category":"page"},{"location":"hardwares/#Supported-Hardwares","page":"Supported Hardwares","title":"Supported Hardwares","text":"","category":"section"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"This section describes basic usage for each supported hardwares.","category":"page"},{"location":"hardwares/#Kvaser","page":"Supported Hardwares","title":"Kvaser","text":"","category":"section"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"KvaserInterface supports Win64 platform.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"To setup interface, do something like below,","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"using CANBus\n\nkvaser0 = KvaserInterface(0, 500000)  # channel 0, 500kbps","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"For CAN FD,","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"kvaser0 = KvaserFDInterface(0, 500000, 2000000)  # channel 0, 500kbps, 2Mbps","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"send, recv, shutdown functions can be use.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"Kvaser's api library is redistributed with CANBus.jl after its license, users does not need to install them separately.","category":"page"},{"location":"hardwares/#SocketCAN","page":"Supported Hardwares","title":"SocketCAN","text":"","category":"section"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"SocketCANInterface supports Linux platform.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"To setup interface, ","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"using CANBus\n\nsockcan0 = SocketCANInterface(\"can0\")  # channel \"can0\"","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"For CAN FD,","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"sockcan0 = SocketCANFDInterface(\"can0\")  # channel \"can0\"","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"send, recv, shutdown functions can be use.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"Bitrate can not be modified from socket api, use ip link command from terminal.","category":"page"},{"location":"hardwares/#Vector","page":"Supported Hardwares","title":"Vector","text":"","category":"section"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"VectorInterface supports Win64 platform. ","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"In this time, author does not get permission to distribute DLLs. So to use this interface,  please install Vector XL-Driver-Library separately. Check vxlapi64.dll is in your path.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"using CANBus\n\nvector1 = VectorInterface(0, 500000, \"NewApp\") # channel 0, 500kbps, application name","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"\"Application name\" means corresponding name in Vector Hardware Manager.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"For CAN FD,","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"vector1 = VectorFDInterface(0, 500000, 2000000, \"NewApp\")\n# channel 0, 500kbps, 2Mbps, application name","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"send, recv, shutdown functions can be use.","category":"page"},{"location":"#CANBus.jl","page":"Home","title":"CANBus.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A can-bus communication package for Julia.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CANBus.jl is a package for communicating on Controller Area Network (CAN, CANbus), supports several hardware interfaces.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Setup device and Transmit/Receive CAN messages in unified easy way.\nCAN FD support (experimental).","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install from GitHub.","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/ichiro-kazusa/CANBus.jl","category":"page"},{"location":"#TODO","page":"Home","title":"TODO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"supports Bit-Timings configuration\nsupports other interfaces\nsupports multi-threading\nsupports async programming","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#Low-level-APIs-for-handle-driver","page":"Internals","title":"Low level APIs for handle driver","text":"","category":"section"},{"location":"internals/#Kvaser","page":"Internals","title":"Kvaser","text":"","category":"section"},{"location":"internals/#CANBus.Interfaces.KvaserInterfaces.Canlib","page":"Internals","title":"CANBus.Interfaces.KvaserInterfaces.Canlib","text":"Low level API for Kvaser CANlib SDK\n\n\n\n\n\n","category":"module"},{"location":"internals/#SocketCAN","page":"Internals","title":"SocketCAN","text":"","category":"section"},{"location":"internals/#CANBus.Interfaces.SocketCANInterfaces.SocketCAN","page":"Internals","title":"CANBus.Interfaces.SocketCANInterfaces.SocketCAN","text":"Low level API for SocketCAN\n\n\n\n\n\n","category":"module"},{"location":"internals/#Vector","page":"Internals","title":"Vector","text":"","category":"section"},{"location":"internals/#CANBus.Interfaces.VectorInterfaces.Vxlapi","page":"Internals","title":"CANBus.Interfaces.VectorInterfaces.Vxlapi","text":"Low level API for Vector XL Driver Library\n\n\n\n\n\n","category":"module"}]
}
