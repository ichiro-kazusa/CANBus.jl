var documenterSearchIndex = {"docs":
[{"location":"interfacecfgs/#InterfaceCfgs","page":"InterfaceCfgs","title":"InterfaceCfgs","text":"","category":"section"},{"location":"interfacecfgs/#InterfaceConfig","page":"InterfaceCfgs","title":"InterfaceConfig","text":"","category":"section"},{"location":"interfacecfgs/#CANBus.InterfaceCfgs.InterfaceConfig","page":"InterfaceCfgs","title":"CANBus.InterfaceCfgs.InterfaceConfig","text":"InterfaceConfig(device::DeviceType, channel::Union{String,Int},\n    bustype::BusType, bitrate::Int;\n    datarate=nothing, silent=false,\n    sample_point=70, sample_point_fd=70,\n    stdfilter=nothing, extfilter=nothing,\n    vector_appname=\"CANalyzer\", slcan_serialbaud=2_000_000)\n\nStrunct for interface configuration.\n\n\n\n\n\n","category":"type"},{"location":"interfacecfgs/#CANBus.InterfaceCfgs.InterfaceConfig-Tuple{CANBus.InterfaceCfgs.DeviceType, Union{Int64, String}, CANBus.InterfaceCfgs.BusType, Int64}","page":"InterfaceCfgs","title":"CANBus.InterfaceCfgs.InterfaceConfig","text":"Always required:\n\ndevice: ::DeviceType. (KVASER, SLCAN...)\nchannel: Device specific channel name(0, can0, COM3...).\nbustype: ::BusType. (CAN_20, CAN_FD...)\n\nRequired kwarg when bustype is CAN_FD or CAN_FD_NONISO:\n\ndatarate\n\nOther optional kwargs:\n\nsilent: Bool. silent mode for some devices. (default: false)\nsample_point: Real. sample point in percentage for CAN2.0. (default: 70)\nsample_point_fd: Real. sample point in percentage for CAN-FD. (default: 70)\nstdfilter: ::AcceptanceFilter or Vector{AcceptanceFilter} or nothing. standard id filter. (default: nothing)\nextfilter: ::AcceptanceFilter or Vector{AcceptanceFilter} or nothing. extended id filter. (default: nothing)\nvector_appname: String. application name for Vector device. (default: \"CANalyzer\")\nslcan_serialbaud: Integer. serial baudrate for slcan device. (default: 2000000)\n\nDevice silent sample_point/_fd std/extfilter vector_appname\nKVASER ✓ ✓ ✓ ign\nSLCAN ✓ ign ign ign\nSOCKETCAN ign ign ✓ ign\nVECTOR ✓ ✓ ✓ ◯\n\n◯:required, ✓:supported, ign:ignored.\n\nSee Hardwares section to see vendor specific notations.\n\n\n\n\n\n","category":"method"},{"location":"interfacecfgs/#CANBus.InterfaceCfgs.InterfaceConfigCAN-Tuple{CANBus.InterfaceCfgs.DeviceType, Union{Int64, String}, Int64}","page":"InterfaceCfgs","title":"CANBus.InterfaceCfgs.InterfaceConfigCAN","text":"InterfaceConfigCAN(device::DeviceType, channel::Union{String,Int},\n    bitrate::Int; kwargs...)\n\nHelper function to construct InterfaceConfig object for CAN2.0 setup. kwargs is same as InterfaceConfig constructor.\n\n\n\n\n\n","category":"method"},{"location":"interfacecfgs/#CANBus.InterfaceCfgs.InterfaceConfigFD-Tuple{CANBus.InterfaceCfgs.DeviceType, Union{Int64, String}, Int64, Int64}","page":"InterfaceCfgs","title":"CANBus.InterfaceCfgs.InterfaceConfigFD","text":"InterfaceConfigFD(device::DeviceType, channel::Union{String,Int},\n    bustype::BusType, bitrate::Int, datarate::Int; kwargs...)\n\nHelper function to construct InterfaceConfig object for CAN-FD (ISO type) setup. kwargs is same as InterfaceConfig constructor.\n\n\n\n\n\n","category":"method"},{"location":"interfacecfgs/#Enumerates","page":"InterfaceCfgs","title":"Enumerates","text":"","category":"section"},{"location":"interfacecfgs/#CANBus.InterfaceCfgs.DeviceType","page":"InterfaceCfgs","title":"CANBus.InterfaceCfgs.DeviceType","text":"Device indicator constants.\n\nVECTOR: Vector\nKVASER: Kvaser\nSOCKETCAN: SocketCAN (Linux only)\nSLCAN: Serial CAN (slcan)\n\n\n\n\n\n","category":"type"},{"location":"interfacecfgs/#CANBus.InterfaceCfgs.BusType","page":"InterfaceCfgs","title":"CANBus.InterfaceCfgs.BusType","text":"Bus type indicator constants.\n\nCAN_20: CAN 2.0\nCAN_FD: CAN FD (ISO compliant)\nCAN_FD_NONISO: CAN FD (non-ISO compliant)\n\n\n\n\n\n","category":"type"},{"location":"interfacecfgs/#Fiilter-struct","page":"InterfaceCfgs","title":"Fiilter struct","text":"","category":"section"},{"location":"interfacecfgs/#CANBus.InterfaceCfgs.AcceptanceFilter","page":"InterfaceCfgs","title":"CANBus.InterfaceCfgs.AcceptanceFilter","text":"AcceptanceFilter(code_id, mask)\n\nStruct for accept filter. \n\nIf this struct is set to Interface, the id is accepted when  <received_id> & mask == code_id & mask or (<received_id> xor code_id) & mask == 0. Those are equivalent.\n\n\n\n\n\n","category":"type"},{"location":"interfacecfgs/","page":"InterfaceCfgs","title":"InterfaceCfgs","text":"","category":"page"},{"location":"frames/#Frames","page":"Frames","title":"Frames","text":"","category":"section"},{"location":"frames/","page":"Frames","title":"Frames","text":"In CANBus.jl, send/receive messages are represented in CANBus.Frames module. For CAN frame, Frame is used, or for CAN FD frame, FDFrame is used.","category":"page"},{"location":"frames/#Base-type","page":"Frames","title":"Base type","text":"","category":"section"},{"location":"frames/#CANBus.Frames.AbstractFrame","page":"Frames","title":"CANBus.Frames.AbstractFrame","text":"Abstract type for Frames.\n\n\n\n\n\n","category":"type"},{"location":"frames/#Frame","page":"Frames","title":"Frame","text":"","category":"section"},{"location":"frames/#CANBus.Frames.Frame","page":"Frames","title":"CANBus.Frames.Frame","text":"Frame(id::Integer, data::AbstractVector;\n    timestamp::Float64=0, is_extended::Bool=false, \n    is_remote_frame::Bool=false, is_error_frame::Bool=false)\n\nFrame struct represents classic (MAX 8bytes) CAN frame.\n\nid: arbitration id\ndata: Vector of Integer with length <= 8. If input has element > 255, throws error.\n\nkwargs:\n\ntimestamp: When receive, arrive time stamp is set in this field. When transmission, this field is not cared.\nThe time stamp is unixtime in sedoncs with fractional part.\nis_extended: Flag which arbitration id is extended. default=false\nis_remote_frame: Flag which indicates remote frame. default=false\nis_error_frame : Flag which indicates error frame. Cared in RX only. default=false\n\nframe = CANBus.Frame(0x5, [1, 2, 3, 4, 5, 6, 7, 8]; is_extended=true)\n\n\n\n\n\n","category":"type"},{"location":"frames/#FDFrame","page":"Frames","title":"FDFrame","text":"","category":"section"},{"location":"frames/#CANBus.Frames.FDFrame","page":"Frames","title":"CANBus.Frames.FDFrame","text":"FDFrame(id::Integer, data::AbstractVector;\n    timestamp::Float64=0, is_extended::Bool=false,\n    bitrate_switch::Bool=true, error_state::Bool=false, is_error_frame::Bool=false)\n\nFDFrame struct represents CAN FD (MAX 64bytes) frame.\n\nid: arbitration id\ndata: Vector of Integer. Length must be in CAN FD DLC standard. Elements must not be > 255.\n\nkwargs:\n\ntimestamp: When receive, arrive time stamp is set in this field. When transmission, this field is not cared.\nThe time stamp is unixtime in sedoncs with fractional part.\nis_extended: Flag which arbitration id is extended. default=false\nbitrate_switch: Flag to use bitrate_switch. default=true\nerror_state: Flag corresponds to error_state_indicator. Cared in RX only. default=false\nis_error_frame : Flag which indicates error frame. Cared in RX only. default=false\n\n\n\n\n\n","category":"type"},{"location":"frames/#References","page":"Frames","title":"References","text":"","category":"section"},{"location":"frames/#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:CANBus.Frames.AbstractFrame","page":"Frames","title":"Base.:==","text":"Base.:(==)(msg1::T, msg2::T) where {T<:CANBus.Frames.AbstractFrame}\n\nCompare two Frames or FDFrames except timestamp field.\n\n\n\n\n\n","category":"method"},{"location":"frames/#Base.length-Tuple{T} where T<:CANBus.Frames.AbstractFrame","page":"Frames","title":"Base.length","text":"Base.length(msg::T) where {T<:CANBus.Frames.AbstractFrame}\n\nReturn length of data field.\n\n\n\n\n\n","category":"method"},{"location":"frames/#Compatibility-with-CANalyze.jl-package","page":"Frames","title":"Compatibility with CANalyze.jl package","text":"","category":"section"},{"location":"frames/","page":"Frames","title":"Frames","text":"Frame and FDFrame has intercompatibility with CANalyze.CANFrame and CANAlyze.CANFdFrame respectively.","category":"page"},{"location":"frames/","page":"Frames","title":"Frames","text":"For instance, Frame constructor has a converter from CANalyze.CANFrame struct, you can use it like below:","category":"page"},{"location":"frames/","page":"Frames","title":"Frames","text":"using CANBus\nusing CANalyze\n\nvector1 = VectorInterface(0, 500000, \"NewApp\")\n\nfrm = CANalyze.CANFrame(1, [1, 2, 3, 4, 5, 6, 7, 8])\nmsg = Frame(frm)\nsend(vector1, msg)","category":"page"},{"location":"frames/","page":"Frames","title":"Frames","text":"In the opposite direction, CANalyze.CANFrame and CANalyze.CANFdFrame constructors are overridden,  so that you can feed Frame and FDFrame structs to CANalyze.Decode.decode function with conversion.","category":"page"},{"location":"frames/","page":"Frames","title":"Frames","text":"frm = CANBus.Frame(0x0e, [1, 2, 3, 4]; is_extended=true)\n\nsignal = CANalyze.Signals.NamedSignal(\"myfloat\", nothing, nothing,\n    CANalyze.Signals.Float32Signal(start=0; byte_order=:little_endian))\nmsg = CANalyze.Messages.Message(0x0e, 4, \"msg1\", signal)\n\nd = CANalyze.Decode.decode(msg, CANalyze.Frames.CANFrame(frm))","category":"page"},{"location":"frames/#Converting-APIs","page":"Frames","title":"Converting APIs","text":"","category":"section"},{"location":"frames/#CANBus.Frames.Frame-Tuple{CANalyze.Frames.CANFrame}","page":"Frames","title":"CANBus.Frames.Frame","text":"Frame(frm::CANalyze.CANFrame)\n\nThis constructor converts CANalyze.CANFrame to CANBus.Frame.\n\n\n\n\n\n","category":"method"},{"location":"frames/#CANalyze.Frames.CANFrame-Tuple{Frame}","page":"Frames","title":"CANalyze.Frames.CANFrame","text":"CANalyze.Frames.CANFrame(frame::Frame)\n\nThis constructor converts CANBus.Frame to CANalyze.CANFrame.\n\n\n\n\n\n","category":"method"},{"location":"frames/#CANBus.Frames.FDFrame-Tuple{CANalyze.Frames.CANFdFrame}","page":"Frames","title":"CANBus.Frames.FDFrame","text":"FDFrame(frm::CANalyze.CANFdFrame; bitrate_switch::Bool=true)\n\nThis constructor converts CANalyze.CANFdFrame to CANBus.FDFrame.\n\n\n\n\n\n","category":"method"},{"location":"frames/#CANalyze.Frames.CANFdFrame-Tuple{FDFrame}","page":"Frames","title":"CANalyze.Frames.CANFdFrame","text":"CANalyze.Frames.CANFdFrame(frame::FDFrame)\n\nThis constructor converts CANBus.FDFrame to CANalyze.CANFdFrame.\n\n\n\n\n\n","category":"method"},{"location":"frames/","page":"Frames","title":"Frames","text":"","category":"page"},{"location":"interfaces/#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"interfaces/#Interface","page":"Interfaces","title":"Interface","text":"","category":"section"},{"location":"interfaces/#CANBus.Interfaces.Interface","page":"Interfaces","title":"CANBus.Interfaces.Interface","text":"iface = Interface(ifacecfg::InterfaceConfig)\n\nSetup CAN Bus Interfaces. \n\n\n\n\n\nInterface(ifacecfg::InterfaceConfig) do iface\n    # do something like:\n    # ret = recv(iface)\nend\n\ndo statement is also supported.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#CANBus.Interfaces.send","page":"Interfaces","title":"CANBus.Interfaces.send","text":"send(interface::T<:Interface, frame::AbstractFrame)\n\nfunction for send message.\n\nIt behaves:\n\nWhen send successed, returns nothing.\nWhen send failed, throws error.\nClassic CAN interfaces can send ONLY Frame\nCAN FD interfaces can send both Frame and FDFrame\n\n\n\n\n\n","category":"function"},{"location":"interfaces/#CANBus.Interfaces.recv","page":"Interfaces","title":"CANBus.Interfaces.recv","text":"recv(interface::T<:Interface; timeout_s::Real=0)\n\nfunction for receive message.\n\nIt behaves:\n\nDefault non-blocking.\nFor blocking receivement, set kwarg timeout_s in seconds. \nSet timeout_s < 0 for infinite bloking.\nWhen receive successed, returns Frame or FDFrame.\nWhen receive queue is empty, returns nothing.\nWhen fails to receive in other reasons, throws error.\nClassic CAN interfaces return only Frame object (except slcan).\nCAN FD compliant interfaces return either Frame or FDFrame object.\n\n\n\n\n\n","category":"function"},{"location":"interfaces/#CANBus.Interfaces.shutdown","page":"Interfaces","title":"CANBus.Interfaces.shutdown","text":"shutdown(interface::T<:Interface)\n\nfunction for shutdown interface. Always returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"interfaces/","page":"Interfaces","title":"Interfaces","text":"","category":"page"},{"location":"examples/#Example-Usage","page":"Example Usage","title":"Example Usage","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Let us assume that we have 2-channel Vector interface, the simplest example is below:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"using CANBus\n\n\nfunction main()\n    bustype = CAN_FD\n\n    device = VECTOR\n\n    ch0 = 0\n    ch1 = 1\n\n    # -------------------------------------\n\n    ifcfg1 = InterfaceConfig(device, ch0, bustype, 500000;\n        datarate=2000000, vector_appname=\"NewApp\")\n\n    f = AcceptanceFilter(0x02, 0x02)\n\n    ifcfg2 = InterfaceConfig(device, ch1, bustype, 500000;\n        datarate=2000000, vector_appname=\"NewApp\", stdfilter=f)\n\n    iface1 = Interface(ifcfg1)\n    Interface(ifcfg2) do iface2 # do-end example\n\n        frm1 = Frame(0x02, [00, 01, 02, 03, 04, 05])\n        frm2 = FDFrame(0x02, collect(1:12); is_extended=true)\n        send(iface1, frm1)\n        send(iface1, frm2)\n\n        sleep(0.1)\n\n        ret1 = recv(iface2; timeout_s=1)\n        println(ret1)\n\n        ret2 = recv(iface2; timeout_s=1)\n        println(ret2)\n\n    end\n    shutdown(iface1)\n\nend\n\nmain()","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Arguments of interface setup are different depends on kind of interface, see Supported Hardwares.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"","category":"page"},{"location":"hardwares/#Supported-Hardwares","page":"Supported Hardwares","title":"Supported Hardwares","text":"","category":"section"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"This section describes basic usage for each supported hardwares.","category":"page"},{"location":"hardwares/#Kvaser","page":"Supported Hardwares","title":"Kvaser","text":"","category":"section"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"KVASER supports Win64 platform.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"This interface requires canlib32.dll (supposed to be installed along with the device driver). ","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"To setup interface, do something like below,","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"cfg = InterfaceConfigCAN(KVASER, 0, 500_000) # channel 0, 500kbps\niface = Interface(cfg)","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"For CAN FD,","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"cfg = InterfaceConfigFD(KVASER, 0, 500_000, 2_000_000) # channel 0, 500kbps, 2Mbps\niface = Interface(cfg)  ","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"note: Note for Filter\nKVASER interface has separate acceptance filters for standard IDs and extended IDs. Each type can have only one filter. Therefore, when setting filters, make sure to  strictly match the ID type. If Vector of AcceptanceFilter is provided, only first one  will be applied.","category":"page"},{"location":"hardwares/#slcan","page":"Supported Hardwares","title":"slcan","text":"","category":"section"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"SLCAN supports Win64/Linux platform. Tested on CANable 2.0 firmware.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"To setup interface, ","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"cfg = InterfaceConfigCAN(SLCAN, \"COM3\", 500_000) # channel COM3, 500kbps\niface = Interface(cfg)","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"channel name is supposed to be like COM3 on Windows, like /dev/ttyACM0 on Linux.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"For CAN FD,","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"cfg = InterfaceConfigFD(SLCAN, \"COM3\", 500_000, 2_000_000) # channel COM3, 500kbps, 2Mbps\niface = Interface(cfg)  ","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"CAN FD on SLCAN, datarate can be chosen from 2000000, 5000000.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"note: Note\nSLCAN with FD firmware (b158aa7) is seemd to be always on FD mode, thus there is no pure CAN mode. Therefore, even if this interface is set up for CAN_20, exceptionally receives FDFrame when someone sends that.","category":"page"},{"location":"hardwares/#SocketCAN","page":"Supported Hardwares","title":"SocketCAN","text":"","category":"section"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"SOCKETCAN supports Linux platform.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"To setup interface, ","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"cfg = InterfaceConfigCAN(SOCKETCAN, \"can0\", 0) # bitrate is ignored.\niface = Interface(cfg)","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"For CAN FD,","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"cfg = InterfaceConfigFD(SOCKETCAN, \"can0\", 0, 0) # bitrate, datarate is ignored.\niface = Interface(cfg)","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"note: Note\nBitrate and Datarate can not be modified from CANBus library, so use ip link command from terminal.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"note: Note for Filter\nThe acceptance filter of the SOCKETCAN interface does not internally distinguish between standard and extended IDs. Therefore, for example, if you set options for stdfilter, the extfilter will not receive any messages unless you explicitly configured to do so.","category":"page"},{"location":"hardwares/#Vector","page":"Supported Hardwares","title":"Vector","text":"","category":"section"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"VECTOR supports Win64 platform. ","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"To use this interface,  please install Vector XL-Driver-Library separately. Check vxlapi64.dll is in your path.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"cfg = InterfaceConfigCAN(VECTOR, 0, 500_000; vector_appname=\"NewApp\") # channel 0, 500kbps\niface = Interface(cfg)","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"vector_appname kwarg is always required. It means corresponding name in Vector Hardware Manager.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"For CAN FD,","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"cfg = InterfaceConfigFD(VECTOR, 0, 500_000, 2_000_000; vector_appname=\"NewApp\") # channel 0, 500kbps, 2Mbps\niface = Interface(cfg)  ","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"AcceptanceFilter has same behavior as KVASER interface.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"","category":"page"},{"location":"changelog/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"changelog/#v0.0.6","page":"Changelog","title":"v0.0.6","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Breaks Compatibility: New generic Interface setup API.\nOld vendor-specific APIs are no longer available.\nSupport do-end statement for Interface.\nAdd automatic bit-timing calculation from samplepoint.\nTested on physical hardware (Vector, Kvaser).\nbug fix: Timeout notification object is infinitely reproduced (Vector).\nbug fix: Infinite waiting when rx buffer is not empty (Vector, Slcan).\nbug fix: Handle leakage when stopping by error (all devices).","category":"page"},{"location":"changelog/#v0.0.5","page":"Changelog","title":"v0.0.5","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Add receive timestamps\nAdd receive timeout","category":"page"},{"location":"changelog/#v0.0.4","page":"Changelog","title":"v0.0.4","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"slcan (CANable2.0) support\nRedesigned Frame and FDFrame (breaks compatibility)\nAdd RTR frame and ERR frame ","category":"page"},{"location":"changelog/#v0.0.1-v0.0.3","page":"Changelog","title":"v0.0.1-v0.0.3","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"first alpha release.","category":"page"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Supports Kvaser, SocketCAN, Vector interfaces\nSupports CAN, Ext.ID.\nSupports CAN FD\nSupports Filter","category":"page"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"","category":"page"},{"location":"#CANBus.jl","page":"Home","title":"CANBus.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A can-bus communication package for Julia.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CANBus.jl is a package for communicating on Controller Area Network (CAN, CANBus), supports several hardware interfaces.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Setup device and Transmit/Receive CAN messages in unified easy way.\nPure julia implementation, directly calls native or C apis, does not depend on other languages.\nCAN FD support.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install via package mode.","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add CANBus","category":"page"},{"location":"#TODO","page":"Home","title":"TODO","text":"","category":"section"},{"location":"#Upcoming-plans-until-v0.1.0","page":"Home","title":"Upcoming plans until v0.1.0","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Careful error-handling.\nAdd Bus state check function\nTry to support PCAN-Basic API for Windows.\nSupport other interfaces.\nPerformance optimization.\nThread-safe send (shareable send interfaces between threads).","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"\nclassDiagram\n\n    namespace core{\n        class InterfaceCfgs\n        class Frames\n    }\n\n    namespace misc{\n        class VendorAPIs:::classFocus\n        class CommonAPIs:::classFocus\n    }\n\n    class ConcreteDevices:::classFocus\n\n    class Devices:::classFocus\n    <<interface>> Devices\n    Interfaces *.. Devices\n    Interfaces ..> InterfaceCfgs\n    Interfaces ..> Frames\n\n    Devices <|.. \"1..*\"ConcreteDevices\n    ConcreteDevices ..> VendorAPIs\n    ConcreteDevices ..> CommonAPIs\n    ConcreteDevices ..> Frames\n    ConcreteDevices ..> InterfaceCfgs\n\n\n    classDef classFocus fill:#baffc6,stroke:#29862c;\n   ","category":"page"},{"location":"internals/#Devices","page":"Internals","title":"Devices","text":"","category":"section"},{"location":"internals/#Abstract-type-and-functions","page":"Internals","title":"Abstract type and functions","text":"","category":"section"},{"location":"internals/#CANBus.Interfaces.Devices.AbstractDevice","page":"Internals","title":"CANBus.Interfaces.Devices.AbstractDevice","text":"Base Type of Devices \n\n\n\n\n\n","category":"type"},{"location":"internals/#CANBus.Interfaces.Devices.dev_open-Tuple{Val, InterfaceConfig}","page":"Internals","title":"CANBus.Interfaces.Devices.dev_open","text":"Abstract function for setup and open device. \n\n\n\n\n\n","category":"method"},{"location":"internals/#CANBus.Interfaces.Devices.dev_send-Tuple{CANBus.Interfaces.Devices.AbstractDevice, Union{FDFrame, Frame}}","page":"Internals","title":"CANBus.Interfaces.Devices.dev_send","text":"Abstract function for send frame. \n\n\n\n\n\n","category":"method"},{"location":"internals/#CANBus.Interfaces.Devices.dev_recv-Tuple{CANBus.Interfaces.Devices.AbstractDevice}","page":"Internals","title":"CANBus.Interfaces.Devices.dev_recv","text":"Abstract function for receive frame. \n\n\n\n\n\n","category":"method"},{"location":"internals/#CANBus.Interfaces.Devices.dev_close-Tuple{CANBus.Interfaces.Devices.AbstractDevice}","page":"Internals","title":"CANBus.Interfaces.Devices.dev_close","text":"Abstract function for close device. \n\n\n\n\n\n","category":"method"},{"location":"internals/#ConcreteDevices","page":"Internals","title":"ConcreteDevices","text":"","category":"section"},{"location":"internals/#Kvaser","page":"Internals","title":"Kvaser","text":"","category":"section"},{"location":"internals/#CANBus.Interfaces.Devices.KvaserDevices.KvaserDevice","page":"Internals","title":"CANBus.Interfaces.Devices.KvaserDevices.KvaserDevice","text":"KvaserDevice(handleholder::HandleHolder, time_offset::Float64)\n\nStruct for store Kvaser device handle and time offset.\n\n\n\n\n\n","category":"type"},{"location":"internals/#slcan","page":"Internals","title":"slcan","text":"","category":"section"},{"location":"internals/#CANBus.Interfaces.Devices.SlcanDevices.SlcanDevice","page":"Internals","title":"CANBus.Interfaces.Devices.SlcanDevices.SlcanDevice","text":"SlcanDevice(port::String, bitrate::Integer)\n\nStruct to store SLCAN device handle and buffer.\n\n\n\n\n\n","category":"type"},{"location":"internals/#SocketCAN","page":"Internals","title":"SocketCAN","text":"","category":"section"},{"location":"internals/#CANBus.Interfaces.Devices.SocketCANDevices.SocketCANDevice","page":"Internals","title":"CANBus.Interfaces.Devices.SocketCANDevices.SocketCANDevice","text":"SocketCANDevice(socketholder::SocketHolder)\n\nStruct for store SocketCAN device handle.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Vector","page":"Internals","title":"Vector","text":"","category":"section"},{"location":"internals/#CANBus.Interfaces.Devices.VectorDevices.VectorDevice","page":"Internals","title":"CANBus.Interfaces.Devices.VectorDevices.VectorDevice","text":"VectorDevice(pportHandle::Ref{Vxlapi.XLportHandle}, channelMask::Vxlapi.XLaccess,\n    time_offset::Float64, notification_hnd::Ref{Vxlapi.XLhandle})\n\nStruct to store Vector device port handle, channel mask, time offset, and notification handle.\n\n\n\n\n\n","category":"type"},{"location":"internals/#VendorAPIs","page":"Internals","title":"VendorAPIs","text":"","category":"section"},{"location":"internals/#Kvaser-2","page":"Internals","title":"Kvaser","text":"","category":"section"},{"location":"internals/#CANBus.Interfaces.Devices.KvaserDevices.Canlib","page":"Internals","title":"CANBus.Interfaces.Devices.KvaserDevices.Canlib","text":"Low level API for Kvaser CANlib SDK\n\n\n\n\n\n","category":"module"},{"location":"internals/#slcan-2","page":"Internals","title":"slcan","text":"","category":"section"},{"location":"internals/#CANBus.Interfaces.Devices.SlcanDevices.slcandef","page":"Internals","title":"CANBus.Interfaces.Devices.SlcanDevices.slcandef","text":"Vendor specific defs for slcan \n\n\n\n\n\n","category":"module"},{"location":"internals/#SocketCAN-2","page":"Internals","title":"SocketCAN","text":"","category":"section"},{"location":"internals/#CANBus.Interfaces.Devices.SocketCANDevices.SocketCAN","page":"Internals","title":"CANBus.Interfaces.Devices.SocketCANDevices.SocketCAN","text":"Low level API for SocketCAN\n\n\n\n\n\n","category":"module"},{"location":"internals/#Vector-2","page":"Internals","title":"Vector","text":"","category":"section"},{"location":"internals/#CANBus.Interfaces.Devices.VectorDevices.Vxlapi","page":"Internals","title":"CANBus.Interfaces.Devices.VectorDevices.Vxlapi","text":"Low level API for Vector XL Driver Library\n\n\n\n\n\n","category":"module"},{"location":"internals/#CommonAPIs","page":"Internals","title":"CommonAPIs","text":"","category":"section"},{"location":"internals/#SerialHAL","page":"Internals","title":"SerialHAL","text":"","category":"section"},{"location":"internals/#CANBus.misc.SerialHAL","page":"Internals","title":"CANBus.misc.SerialHAL","text":"Abstraction layer for serial port communication.\n\n\n\n\n\n","category":"module"},{"location":"internals/#WinWrap","page":"Internals","title":"WinWrap","text":"","category":"section"},{"location":"internals/#CANBus.misc.WinWrap","page":"Internals","title":"CANBus.misc.WinWrap","text":"Wrappers for Windows system call.\n\n\n\n\n\n","category":"module"},{"location":"internals/#BitTiming","page":"Internals","title":"BitTiming","text":"","category":"section"},{"location":"internals/#CANBus.misc.BitTiming","page":"Internals","title":"CANBus.misc.BitTiming","text":"Internal module for BitTiming calculation and setting.\n\n\n\n\n\n","category":"module"},{"location":"internals/","page":"Internals","title":"Internals","text":"","category":"page"}]
}
