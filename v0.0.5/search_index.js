var documenterSearchIndex = {"docs":
[{"location":"frames/#Frames","page":"Frames","title":"Frames","text":"","category":"section"},{"location":"frames/","page":"Frames","title":"Frames","text":"In CANBus.jl, send/receive messages are represented in CANBus.Frames module. For CAN frame, Frame is used, or for CAN FD frame, FDFrame is used.","category":"page"},{"location":"frames/#Base-type","page":"Frames","title":"Base type","text":"","category":"section"},{"location":"frames/#CANBus.Frames.AbstractFrame","page":"Frames","title":"CANBus.Frames.AbstractFrame","text":"Abstract type for Frames.\n\n\n\n\n\n","category":"type"},{"location":"frames/#Frame","page":"Frames","title":"Frame","text":"","category":"section"},{"location":"frames/#CANBus.Frames.Frame","page":"Frames","title":"CANBus.Frames.Frame","text":"CANBus.Frame(id::Integer, data::AbstractVector;\n    timestamp::Float64=0, is_extended::Bool=false, \n    is_remote_frame::Bool=false, is_error_frame::Bool=false)\n\nFrame struct represents classic (MAX 8bytes) CAN frame.\n\nid: arbitration id\ndata: Vector of Integer with length <= 8. If input has element > 255, throws error.\n\nkwargs:\n\ntimestamp: When receive, arrive time stamp is set in this field. When transmission, this field is not cared.\nis_extended: Flag which arbitration id is extended. default=false\nis_remote_frame: Flag which indicates remote frame. default=false\nis_error_frame : Flag which indicates error frame. Cared in RX only. default=false\n\nframe = CANBus.Frame(0x5, [1, 2, 3, 4, 5, 6, 7, 8]; is_extended=true)\n\n\n\n\n\n","category":"type"},{"location":"frames/#FDFrame","page":"Frames","title":"FDFrame","text":"","category":"section"},{"location":"frames/#CANBus.Frames.FDFrame","page":"Frames","title":"CANBus.Frames.FDFrame","text":"CANBus.FDFrame(id::Integer, data::AbstractVector;\n    timestamp::Float64=0, is_extended::Bool=false,\n    bitrate_switch::Bool=true, error_state::Bool=false, is_error_frame::Bool=false)\n\nFDFrame struct represents CAN FD (MAX 64bytes) frame.\n\nid: arbitration id\ndata: Vector of Integer. Length must be in CAN FD DLC standard. Elements must not be > 255.\n\nkwargs:\n\ntimestamp: When receive, arrive time stamp is set in this field. When transmission, this field is not cared.\nis_extended: Flag which arbitration id is extended. default=false\nbitrate_switch: Flag to use bitrate_switch. default=true\nerror_state: Flag corresponds to error_state_indicator. Cared in RX only. default=false\nis_error_frame : Flag which indicates error frame. Cared in RX only. default=false\n\n\n\n\n\n","category":"type"},{"location":"frames/#Compatibility-with-CANalyze.jl-package","page":"Frames","title":"Compatibility with CANalyze.jl package","text":"","category":"section"},{"location":"frames/","page":"Frames","title":"Frames","text":"Frame and FDFrame has intercompatibility with CANalyze.CANFrame and CANAlyze.CANFdFrame respectively.","category":"page"},{"location":"frames/","page":"Frames","title":"Frames","text":"For instance, Frame constructor has a converter from CANalyze.CANFrame struct, you can use it like below:","category":"page"},{"location":"frames/","page":"Frames","title":"Frames","text":"using CANBus\nusing CANalyze\n\nvector1 = VectorInterface(0, 500000, \"NewApp\")\n\nfrm = CANalyze.CANFrame(1, [1, 2, 3, 4, 5, 6, 7, 8])\nmsg = Frame(frm)\nsend(vector1, msg)","category":"page"},{"location":"frames/","page":"Frames","title":"Frames","text":"In the opposite direction, CANalyze.CANFrame and CANalyze.CANFdFrame constructors are overridden,  so that you can feed Frame and FDFrame structs to CANalyze.Decode.decode function with conversion.","category":"page"},{"location":"frames/","page":"Frames","title":"Frames","text":"frm = CANBus.Frame(0x0e, [1, 2, 3, 4]; is_extended=true)\n\nsignal = CANalyze.Signals.NamedSignal(\"myfloat\", nothing, nothing,\n    CANalyze.Signals.Float32Signal(start=0; byte_order=:little_endian))\nmsg = CANalyze.Messages.Message(0x0e, 4, \"msg1\", signal)\n\nd = CANalyze.Decode.decode(msg, CANalyze.Frames.CANFrame(frm))","category":"page"},{"location":"interfaces/#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"interfaces/#Base-type","page":"Interfaces","title":"Base type","text":"","category":"section"},{"location":"interfaces/#CANBus.Interfaces.AbstractCANInterface","page":"Interfaces","title":"CANBus.Interfaces.AbstractCANInterface","text":"Abstract type for Interfaces.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#CANBus.Interfaces.send","page":"Interfaces","title":"CANBus.Interfaces.send","text":"send(interface::T<:AbstractCANInterface, frame::AbstractFrame)\n\nAbstract function for send message.\n\nCommon behavior of concrete implements:\n\nWhen send successed, return nothing.\nWhen send failed, throws error.\nClassic CAN interfaces can send ONLY Frame\nCAN FD interfaces can send both Frame and FDFrame\n\n\n\n\n\n","category":"function"},{"location":"interfaces/#CANBus.Interfaces.recv","page":"Interfaces","title":"CANBus.Interfaces.recv","text":"recv(interface::T<:AbstractCANInterface; timeout_s::Real=0)\n\nAbstract function for receive message.\n\nCommon behavior of concrete implements:\n\nDefault non-blocking.\nFor blocking receivement, set timeout_s in seconds. \nSet timeout_s < 0 for infinite bloking.\nWhen receive successed, returns Frame or FDFrame.\nWhen receive queue is empty, returns nothing.\nWhen fails to receive in other reasons, throws error.\nClassic CAN interfaces return only Frame object.\nCAN FD interfaces return either Frame or FDFrame object.\n\n\n\n\n\n","category":"function"},{"location":"interfaces/#CANBus.Interfaces.shutdown","page":"Interfaces","title":"CANBus.Interfaces.shutdown","text":"shutdown(interface::T<:AbstractCANInterface)\n\nAbstract function for shutdown interface. Always returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"interfaces/#Fiilter-struct","page":"Interfaces","title":"Fiilter struct","text":"","category":"section"},{"location":"interfaces/#CANBus.Interfaces.AcceptanceFilter","page":"Interfaces","title":"CANBus.Interfaces.AcceptanceFilter","text":"AcceptanceFilter(code_id, mask)\n\nStruct for accept filter. \n\nIf this struct is set to Interface, the id is accepted when  <received_id> & mask == code_id & mask or (<received_id> xor code_id) & mask == 0. Those are equivalent.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#Kvaser","page":"Interfaces","title":"Kvaser","text":"","category":"section"},{"location":"interfaces/#CANBus.Interfaces.KvaserInterfaces.KvaserInterface","page":"Interfaces","title":"CANBus.Interfaces.KvaserInterfaces.KvaserInterface","text":"KvaserInterface(channel::Int, bitrate::Int;\n    silent::Bool, stdfilter::AcceptanceFilter, extfilter::AcceptanceFilter)\n\nSetup Kvaser interface\n\nchannel: channel number in integer.\nbitrate: bitrate as bit/s in integer.\nsilent(optional): listen only flag in bool.\nstdfilter(optional): standard ID filter in AcceptanceFilter struct.\nextfilter(optional): extended ID filter in AcceptanceFilter struct.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#CANBus.Interfaces.KvaserInterfaces.KvaserFDInterface","page":"Interfaces","title":"CANBus.Interfaces.KvaserInterfaces.KvaserFDInterface","text":"KvaserFDInterface(channel::Int, bitrate::Int, datarate::Int;\n    non_iso::Bool, silent::Bool, stdfilter::AcceptanceFilter, extfilter::AcceptanceFilter)\n\nSetup Kvaser interface for CAN FD.\n\nchannel: channel number in integer.\nbitrate: bitrate as bit/s in integer.\ndatarate: datarate as bit/s in integer.\nnon_iso(optional): use non-iso version of CAN FD\nsilent(optional): listen only flag in bool.\nstdfilter(optional): standard ID filter in AcceptanceFilter struct.\nextfilter(optional): extended ID filter in AcceptanceFilter struct.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#slcan","page":"Interfaces","title":"slcan","text":"","category":"section"},{"location":"interfaces/","page":"Interfaces","title":"Interfaces","text":"slcan does not support hardware filter.","category":"page"},{"location":"interfaces/#CANBus.Interfaces.SlcanInterfaces.SlcanInterface","page":"Interfaces","title":"CANBus.Interfaces.SlcanInterfaces.SlcanInterface","text":"slcan0 = SlcanInterface(port::String, bitrate::Integer)\n\nslcan is a CAN over serial protocol by CANable. This version is tested on CANable 2.0.\n\nnote: Note\nslcan with FD firmware (b158aa7) is seemd to be always on FD mode, thus there is no pure CAN mode. Therefore, this interface exceptionally receives FDFrame when someone sends that.\n\nport: port name string e.g. COM3 on Windows,  /dev/ttyACM0 on Linux.\nbitrate: bit rate in bit/s\nsilent(optional): listen only flag in bool.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#CANBus.Interfaces.SlcanInterfaces.SlcanFDInterface","page":"Interfaces","title":"CANBus.Interfaces.SlcanInterfaces.SlcanFDInterface","text":"slcan0 = SlcanFDInterface(port::String, bitrate::Integer, datarate::Integer)\n\nslcan is a CAN over serial protocol by CANable. This version is tested on CANable 2.0. This interface supports send CAN FD frame.\n\nport: port name string.\nbitrate: bit rate in bit/s\ndatarate: data rate in bit/s\nsilent(optional): listen only flag in bool.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#SocketCAN","page":"Interfaces","title":"SocketCAN","text":"","category":"section"},{"location":"interfaces/#CANBus.Interfaces.SocketCANInterfaces.SocketCANInterface","page":"Interfaces","title":"CANBus.Interfaces.SocketCANInterfaces.SocketCANInterface","text":"SocketCANInterface(channel::String; filters::Vector{AcceptanceFilter})\n\nSetup SocketCAN interface.\n\nchannel: channel name string, e.g. \"can0\"\nfilters(optional): list of filters. experimental.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#CANBus.Interfaces.SocketCANInterfaces.SocketCANFDInterface","page":"Interfaces","title":"CANBus.Interfaces.SocketCANInterfaces.SocketCANFDInterface","text":"SocketCANFDInterface(channel::String; filters::Vector{AcceptanceFilter})\n\nSetup SocketCAN for CAN FD.\n\nchannel: channel name string, e.g. \"can0\"\nfilters(optional): list of filters. experimental.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#Vector","page":"Interfaces","title":"Vector","text":"","category":"section"},{"location":"interfaces/#CANBus.Interfaces.VectorInterfaces.VectorInterface","page":"Interfaces","title":"CANBus.Interfaces.VectorInterfaces.VectorInterface","text":"VectorInterface(channel::Int, bitrate::Int, appname::String)\n\nSetup Vector interface.\n\nchannel: channel number in integer.\nbitrate: bitrate as bit/s in integer.\napppname: Application Name string in Vector Hardware Manager.\nsilent(optional): listen only flag in bool.\nstdfilter(optional): standard ID filter in AcceptanceFilter struct.\nextfilter(optional): extended ID filter in AcceptanceFilter struct.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#CANBus.Interfaces.VectorInterfaces.VectorFDInterface","page":"Interfaces","title":"CANBus.Interfaces.VectorInterfaces.VectorFDInterface","text":"VectorFDInterface(channel::Int, bitrate::Int, datarate::Int, appname::String)\n\nSetup Vector interface for CAN FD.\n\nchannel: channel number in integer.\nbitrate: bitrate as bit/s in integer.\ndatarate: datarate as bit/s in integer.\napppname: Application Name string in Vector Hardware Manager.\nnon_iso(optional): use non-iso version of CAN FD\nsilent(optional): listen only flag in bool.\nstdfilter(optional): standard ID filter in AcceptanceFilter struct.\nextfilter(optional): extended ID filter in AcceptanceFilter struct.\n\n\n\n\n\n","category":"type"},{"location":"examples/#Example-Usage","page":"Example Usage","title":"Example Usage","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Let us assume that we have 2-channel Vector interface, the simplest example is below:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"using CANBus\n\nfunction main()\n    vector1 = VectorInterface(0, 500000, \"NewApp\")\n    vector2 = VectorInterface(1, 500000, \"NewApp\")\n\n    frame = CANBus.Frame(15, [1, 1, 2, 2, 3, 3, 4])\n\n    send(vector1, frame)\n\n    frame = recv(vector2) # non-blocking receive\n    println(frame)\n\n    frame = recv(vector2) # returns nothing\n    println(frame)\n\n    shutdown(vector1)\n    shutdown(vector2)\nend\n\nmain()","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Arguments of interface setup are different depends on kind of interface, see References.","category":"page"},{"location":"hardwares/#Supported-Hardwares","page":"Supported Hardwares","title":"Supported Hardwares","text":"","category":"section"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"This section describes basic usage for each supported hardwares.","category":"page"},{"location":"hardwares/#Kvaser","page":"Supported Hardwares","title":"Kvaser","text":"","category":"section"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"KvaserInterface supports Win64 platform.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"This interface requires canlib32.dll (should be installed along with the device driver). ","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"To setup interface, do something like below,","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"using CANBus\n\nkvaser0 = KvaserInterface(0, 500000)  # channel 0, 500kbps","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"For CAN FD,","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"kvaser0 = KvaserFDInterface(0, 500000, 2000000)  # channel 0, 500kbps, 2Mbps","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"send, recv, shutdown functions can be use.","category":"page"},{"location":"hardwares/#slcan","page":"Supported Hardwares","title":"slcan","text":"","category":"section"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"SlcanInterface supports Win64/Linux platform. Tested on CANable 2.0 firmware.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"To setup interface, ","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"using CANBus\n\nslcan0 = SlcanInterface(\"COM3\", 1000000)  # for Linux, e.g. \"/dev/ttyACM0\"","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"For CAN FD,","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"slcan0 = SocketCANFDInterface(\"COM3\", 1000000, 2000000) # bitrate 1Mbps, datarate 2Mbps","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"CAN FD on slcan, datarate must be chosen from 2000000, 5000000.","category":"page"},{"location":"hardwares/#slcan-2","page":"Supported Hardwares","title":"slcan","text":"","category":"section"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"SlcanInterface supports Win64/Linux platform. Tested on CANable 2.0 firmware.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"To setup interface, ","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"using CANBus\n\nslcan0 = SlcanInterface(\"COM3\", 1000000)  # for Linux, e.g. \"/dev/ttyACM0\"","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"For CAN FD,","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"slcan0 = SocketCANFDInterface(\"COM3\", 1000000, 2000000) # bitrate 1Mbps, datarate 2Mbps","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"CAN FD on slcan, datarate can be chosen from 2000000, 5000000.","category":"page"},{"location":"hardwares/#SocketCAN","page":"Supported Hardwares","title":"SocketCAN","text":"","category":"section"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"SocketCANInterface supports Linux platform.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"To setup interface, ","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"using CANBus\n\nsockcan0 = SocketCANInterface(\"can0\")  # channel \"can0\"","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"For CAN FD,","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"sockcan0 = SocketCANFDInterface(\"can0\")  # channel \"can0\"","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"send, recv, shutdown functions can be use.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"Bitrate can not be modified from socket api, use ip link command from terminal.","category":"page"},{"location":"hardwares/#Vector","page":"Supported Hardwares","title":"Vector","text":"","category":"section"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"VectorInterface supports Win64 platform. ","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"In this time, author does not get permission to distribute DLLs. So to use this interface,  please install Vector XL-Driver-Library separately. Check vxlapi64.dll is in your path.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"using CANBus\n\nvector1 = VectorInterface(0, 500000, \"NewApp\") # channel 0, 500kbps, application name","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"\"Application name\" means corresponding name in Vector Hardware Manager.","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"For CAN FD,","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"vector1 = VectorFDInterface(0, 500000, 2000000, \"NewApp\")\n# channel 0, 500kbps, 2Mbps, application name","category":"page"},{"location":"hardwares/","page":"Supported Hardwares","title":"Supported Hardwares","text":"send, recv, shutdown functions can be use.","category":"page"},{"location":"#CANBus.jl","page":"Home","title":"CANBus.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A can-bus communication package for Julia.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CANBus.jl is a package for communicating on Controller Area Network (CAN, CANBus), supports several hardware interfaces.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Setup device and Transmit/Receive CAN messages in unified easy way.\nPure julia implementation, directly calls native or C apis, does not depend on other languages.\nCAN FD support.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install via package mode.","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add CANBus","category":"page"},{"location":"#TODO","page":"Home","title":"TODO","text":"","category":"section"},{"location":"#Upcoming-plans-until-v0.1.0","page":"Home","title":"Upcoming plans until v0.1.0","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I'm going to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Support Bit-Timing configuration.\nAdd loop back flag.\nAdd blocking-recv function. -> done\nTest Vector & Kvaser interfaces with physical hardware. -> done\nAdd timestamp to frames. -> done\nAdd RTR / Error frame implementation. -> done\nReconsider data structure about CAN/CANFD distinction. -> done","category":"page"},{"location":"#Further-ahead","page":"Home","title":"Further ahead","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Try to support PCAN-Basic API for Windows.\nSupport do~end statement.\nCareful error-handling.\nSupport other interfaces.\nPerformance optimization.\nThread-safe send (shareable send interfaces between threads).","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#Low-level-APIs-for-handle-driver","page":"Internals","title":"Low level APIs for handle driver","text":"","category":"section"},{"location":"internals/#Kvaser","page":"Internals","title":"Kvaser","text":"","category":"section"},{"location":"internals/#CANBus.Interfaces.KvaserInterfaces.Canlib","page":"Internals","title":"CANBus.Interfaces.KvaserInterfaces.Canlib","text":"Low level API for Kvaser CANlib SDK\n\n\n\n\n\n","category":"module"},{"location":"internals/#SerialHAL","page":"Internals","title":"SerialHAL","text":"","category":"section"},{"location":"internals/#CANBus.SerialHAL","page":"Internals","title":"CANBus.SerialHAL","text":"Abstraction layer for serial port communication.\n\n\n\n\n\n","category":"module"},{"location":"internals/#SocketCAN","page":"Internals","title":"SocketCAN","text":"","category":"section"},{"location":"internals/#CANBus.Interfaces.SocketCANInterfaces.SocketCAN","page":"Internals","title":"CANBus.Interfaces.SocketCANInterfaces.SocketCAN","text":"Low level API for SocketCAN\n\n\n\n\n\n","category":"module"},{"location":"internals/#Vector","page":"Internals","title":"Vector","text":"","category":"section"},{"location":"internals/#CANBus.Interfaces.VectorInterfaces.Vxlapi","page":"Internals","title":"CANBus.Interfaces.VectorInterfaces.Vxlapi","text":"Low level API for Vector XL Driver Library\n\n\n\n\n\n","category":"module"}]
}
